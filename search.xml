<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaI/O流(下）</title>
      <link href="/2019/08/08/java-io2/"/>
      <url>/2019/08/08/java-io2/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaI-O知识-下"><a href="#JavaI-O知识-下" class="headerlink" title="JavaI/O知识(下)"></a>JavaI/O知识(下)</h1><h3 id="关闭流的方式"><a href="#关闭流的方式" class="headerlink" title="关闭流的方式"></a>关闭流的方式</h3><p>所有的流，无论是输入流还是输出流，使用完毕之后，都应该关闭。 如果不关闭，会产生对资源占用的浪费。<br>当量比较大的时候，会影响到业务的正常开展。</p><h4 id="在try中关闭"><a href="#在try中关闭" class="headerlink" title="在try中关闭"></a>在try中关闭</h4><p>在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端；<br>如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 不推荐使用</p><h4 id="在finally中关闭"><a href="#在finally中关闭" class="headerlink" title="在finally中关闭"></a>在finally中关闭</h4><p>这是标准的关闭流的方式</p><ol><li><p>首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally.</p></li><li><p>在finally关闭之前，要先判断该引用是否为空</p></li><li><p>关闭的时候，需要再一次进行try catch处理<br>这是标准的严谨的关闭流的方式，但是看上去很繁琐，所以写不重要的或者测试代码的时候，都会采用上面的有隐患try的方式，因为不麻烦</p><pre><code>package stream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;public class TestStream { public static void main(String[] args) {     File f = new File(&quot;d:/lol.txt&quot;);     FileInputStream fis = null;     try {         fis = new FileInputStream(f);         byte[] all = new byte[(int) f.length()];         fis.read(all);         for (byte b : all) {             System.out.println(b);         }     } catch (IOException e) {         e.printStackTrace();     } finally {         // 在finally 里关闭流         if (null != fis)             try {                 fis.close();             } catch (IOException e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }     } }}</code></pre><h4 id="使用try-的方式"><a href="#使用try-的方式" class="headerlink" title="使用try()的方式"></a>使用try()的方式</h4><p>把流定义在try()里,try,catch或者finally结束的时候，会自动关闭<br>这种编写代码的方式叫做 try-with-resources， 这是从JDK7开始支持的技术<br>所有的流，都实现了一个接口叫做 AutoCloseable，任何类实现了这个接口，都可以在try()中进行实例化。<br>并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p><pre><code>package stream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;public class TestStream { public static void main(String[] args) {     File f = new File(&quot;d:/lol.txt&quot;);     //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭     try (FileInputStream fis = new FileInputStream(f)) {         byte[] all = new byte[(int) f.length()];         fis.read(all);         for (byte b : all) {             System.out.println(b);         }     } catch (IOException e) {         e.printStackTrace();     } }}</code></pre><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>Reader字符输入流<br>Writer字符输出流<br>专门用于字符的形式读取和写入数据</p><h4 id="使用字符流读取文件"><a href="#使用字符流读取文件" class="headerlink" title="使用字符流读取文件"></a>使用字符流读取文件</h4><p>FileReader 是Reader子类，以FileReader 为例进行文件读取</p><pre><code>package stream;import java.io.File;import java.io.FileReader;import java.io.IOException;public class TestStream { public static void main(String[] args) {     // 准备文件lol.txt其中的内容是AB     File f = new File(&quot;d:/lol.txt&quot;);     // 创建基于文件的Reader     try (FileReader fr = new FileReader(f)) {         // 创建字符数组，其长度就是文件的长度         char[] all = new char[(int) f.length()];         // 以字符流的形式读取文件所有内容         fr.read(all);         for (char b : all) {             // 打印出来是A B             System.out.println(b);         }     } catch (IOException e) {         // TODO Auto-generated catch block         e.printStackTrace();     } }}</code></pre><h4 id="使用字符流把字符串写入到文件"><a href="#使用字符流把字符串写入到文件" class="headerlink" title="使用字符流把字符串写入到文件"></a>使用字符流把字符串写入到文件</h4><p>FileWriter 是Writer的子类，以FileWriter 为例把字符串写入到文件</p><pre><code>package stream; import java.io.File;import java.io.FileWriter;import java.io.IOException;public class TestStream { public static void main(String[] args) {     // 准备文件lol2.txt     File f = new File(&quot;d:/lol2.txt&quot;);     // 创建基于文件的Writer     try (FileWriter fr = new FileWriter(f)) {         // 以字符流的形式把数据写入到文件中         String data=&quot;abcdefg1234567890&quot;;         char[] cs = data.toCharArray();         fr.write(cs);     } catch (IOException e) {         // TODO Auto-generated catch block         e.printStackTrace();     } }}</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaI/O流(上）</title>
      <link href="/2019/08/07/java-io/"/>
      <url>/2019/08/07/java-io/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaI-O知识-上"><a href="#JavaI-O知识-上" class="headerlink" title="JavaI/O知识(上)"></a>JavaI/O知识(上)</h1><h3 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h3><h4 id="一：创建一个文件对象"><a href="#一：创建一个文件对象" class="headerlink" title="一：创建一个文件对象"></a>一：创建一个文件对象</h4><p>使用绝对路径或者相对路径创建File对象</p><pre><code>package file;import java.io.File;public class TestFile {    public static void main(String[] args) {        // 绝对路径        File f1 = new File(&quot;d:/LOLFolder&quot;);        System.out.println(&quot;f1的绝对路径：&quot; + f1.getAbsolutePath());        // 相对路径,相对于工作目录，如果在eclipse中，就是项目目录        File f2 = new File(&quot;LOL.exe&quot;);        System.out.println(&quot;f2的绝对路径：&quot; + f2.getAbsolutePath());        // 把f1作为父目录创建文件对象        File f3 = new File(f1, &quot;LOL.exe&quot;);        System.out.println(&quot;f3的绝对路径：&quot; + f3.getAbsolutePath());    }}</code></pre><h4 id="文件常用方法"><a href="#文件常用方法" class="headerlink" title="文件常用方法"></a>文件常用方法</h4><p>exists():文件是否存在<br>isDirectory()：是否是文件夹<br>isFile()：是否是文件夹(非文件夹)<br>length()：文件长度<br>getParentFile():获取文件所在的目录（这个文件的父文件）<br>lastModified()：文件最后修改时间<br>setLastModified(0)：设置文件修改时间为1970.1.1 08:00:00<br>File f = new File(“d:/LOLFolder/skin/garen.ski”);<br>f.list()：以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）<br>mkdir()：创建文件夹，如果父文件夹skin不存在，创建无效<br>mkdirs()：创建文件夹，如果父文件夹skin不存在，就会创建父文件夹<br>createNewFile()：创建一个空文件,如果父文件夹skin不存在，就会抛出异常<br>listRoots()：列出所有的盘符c: d: e: 等等<br>delete()：刪除文件<br>f.deleteOnExit()：JVM结束的时候，刪除文件，常用于临时文件的删除<br>File[]fs= f.listFiles()：以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</p><p><font color="red">注意1： 需要在D:\LOLFolder确实存在一个LOL.exe,才可以看到对应的文件长度、修改时间等信息</font><br><font color="red">注意2： renameTo方法用于对物理文件名称进行修改，但是并不会修改File对象的name属性。</font></p><pre><code>package file;import java.io.File;import java.util.Date;public class TestFile {    public static void main(String[] args) {        File f = new File(&quot;d:/LOLFolder/LOL.exe&quot;);        System.out.println(&quot;当前文件是：&quot; +f);        //文件是否存在        System.out.println(&quot;判断是否存在：&quot;+f.exists());        //是否是文件夹        System.out.println(&quot;判断是否是文件夹：&quot;+f.isDirectory());        //是否是文件（非文件夹）        System.out.println(&quot;判断是否是文件：&quot;+f.isFile());        //文件长度        System.out.println(&quot;获取文件的长度：&quot;+f.length());        //文件最后修改时间        long time = f.lastModified();        Date d = new Date(time);        System.out.println(&quot;获取文件的最后修改时间：&quot;+d);        //设置文件修改时间为1970.1.1 08:00:00        f.setLastModified(0);        //文件重命名        File f2 =new File(&quot;d:/LOLFolder/DOTA.exe&quot;);        f.renameTo(f2);        System.out.println(&quot;把LOL.exe改名成了DOTA.exe&quot;);        System.out.println(&quot;注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\r\n才可以看到对应的文件长度、修改时间等信息&quot;);    }}</code></pre><h3 id="流的定义"><a href="#流的定义" class="headerlink" title="流的定义"></a>流的定义</h3><h4 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h4><p>当不同的介质之间有数据交互的时候，JAVA就使用流来实现。<br>数据源可以是文件，还可以是数据库，网络甚至是其他的程序</p><p>比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流<br>输入流： InputStream<br>输出流：OutputStream<br><img src="http://stepimagewm.how2j.cn/759.png" alt></p><h4 id="文件输入流"><a href="#文件输入流" class="headerlink" title="文件输入流"></a>文件输入流</h4><p>建立了一个文件输入流，这个流可以用来把数据从硬盘的文件，读取到JVM(内存)。</p><pre><code>package stream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;public class TestStream {    public static void main(String[] args) {        try {            File f = new File(&quot;d:/lol.txt&quot;);            // 创建基于文件的输入流            FileInputStream fis = new FileInputStream(f);            // 通过这个输入流，就可以把数据从硬盘，读取到Java的虚拟机中来，也就是读取到内存中        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre><p>文件输出流用:FileOutputStream</p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="以字节流的形式读取文件内容"><a href="#以字节流的形式读取文件内容" class="headerlink" title="以字节流的形式读取文件内容"></a>以字节流的形式读取文件内容</h4><p>InputStream是字节输入流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。<br>FileInputStream 是InputStream子类，以FileInputStream 为例进行文件读取</p><pre><code>package stream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;public class TestStream {    public static void main(String[] args) {        try {            //准备文件lol.txt其中的内容是AB，对应的ASCII分别是65 66            File f =new File(&quot;d:/lol.txt&quot;);            //创建基于文件的输入流            FileInputStream fis =new FileInputStream(f);            //创建字节数组，其长度就是文件的长度            byte[] all =new byte[(int) f.length()];            //以字节流的形式读取文件所有内容            fis.read(all);            for (byte b : all) {                //打印出来是65 66                System.out.println(b);            }            //每次使用完流，都应该进行关闭            fis.close();        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre><h4 id="以字节流的形式向文件写入数据"><a href="#以字节流的形式向文件写入数据" class="headerlink" title="以字节流的形式向文件写入数据"></a>以字节流的形式向文件写入数据</h4><p>OutputStream是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。<br>FileOutputStream 是OutputStream子类，以FileOutputStream 为例向文件写出数据</p><p><font color="red">注: 如果文件d:/lol2.txt不存在，写出操作会自动创建该文件。但是如果是文件 d:/xyz/lol2.txt，而目录xyz又不存在，会抛出异常<br></font></p><pre><code>package stream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;public class TestStream {    public static void main(String[] args) {        try {            // 准备文件lol2.txt其中的内容是空的            File f = new File(&quot;d:/lol2.txt&quot;);            // 准备长度是2的字节数组，用88,89初始化，其对应的字符分别是X,Y            byte data[] = { 88, 89 };            // 创建基于文件的输出流            FileOutputStream fos = new FileOutputStream(f);            // 把数据写入到输出流            fos.write(data);            // 关闭输出流            fos.close();        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre><h4 id="写入数据到文件"><a href="#写入数据到文件" class="headerlink" title="写入数据到文件"></a>写入数据到文件</h4><p>以字节流的形式向文件写入数据 中的例子，当lol2.txt不存在的时候，是会自动创建lol2.txt文件的。<br>但是，如果是写入数据到d:/xyz/lol2.txt，而目录xyz又不存在的话，就会抛出异常。<br>那么怎么自动创建xyz目录？<br>如果是多层目录 d:/xyz/abc/def/lol2.txt 呢？</p><pre><code>package stream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;public class TestStream {    public static void main(String[] args) {        try {            File f = new File(&quot;d:/xyz/abc/def/lol2.txt&quot;);            //因为默认情况下，文件系统中不存在 d:\xyz\abc\def，所以输出会失败            //首先获取文件所在的目录            File dir = f.getParentFile();            //如果该目录不存在，则创建该目录            if(!dir.exists()){//              dir.mkdir(); //使用mkdir会抛出异常，因为该目录的父目录也不存在                dir.mkdirs(); //使用mkdirs则会把不存在的目录都创建好            }            byte data[] = { 88, 89 };            FileOutputStream fos = new FileOutputStream(f);            fos.write(data);            fos.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h4 id="拆分文件"><a href="#拆分文件" class="headerlink" title="拆分文件"></a>拆分文件</h4><p>找到一个大于100k的文件，按照100k为单位，拆分成多个子文件，并且以编号作为文件名结束。<br>比如文件 eclipse.exe，大小是309k。<br>拆分之后，成为<br>eclipse.exe-0<br>eclipse.exe-1<br>eclipse.exe-2<br>eclipse.exe-3<br>拆分的思路，先把源文件的所有内容读取到内存中，然后从内存中挨个分到子文件里<br>提示，这里用到了数组复制Arrays.copyOfRange</p><pre><code>package stream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.Arrays;public class TestStream {    public static void main(String[] args) {        int eachSize = 100 * 1024; // 100k        File srcFile = new File(&quot;d:/eclipse.exe&quot;);        splitFile(srcFile, eachSize);    }    /**     * 拆分的思路，先把源文件的所有内容读取到内存中，然后从内存中挨个分到子文件里     * @param srcFile 要拆分的源文件     * @param eachSize 按照这个大小，拆分     */    private static void splitFile(File srcFile, int eachSize) {        if (0 == srcFile.length())            throw new RuntimeException(&quot;文件长度为0，不可拆分&quot;);        byte[] fileContent = new byte[(int) srcFile.length()];        // 先把文件读取到数组中        try {            FileInputStream fis = new FileInputStream(srcFile);            fis.read(fileContent);            fis.close();        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        // 计算需要被划分成多少份子文件        int fileNumber;        // 文件是否能被整除得到的子文件个数是不一样的        // (假设文件长度是25，每份的大小是5，那么就应该是5个)        // (假设文件长度是26，每份的大小是5，那么就应该是6个)        if (0 == fileContent.length % eachSize)            fileNumber = (int) (fileContent.length / eachSize);        else            fileNumber = (int) (fileContent.length / eachSize) + 1;        for (int i = 0; i &lt; fileNumber; i++) {            String eachFileName = srcFile.getName() + &quot;-&quot; + i;            File eachFile = new File(srcFile.getParent(), eachFileName);            byte[] eachContent;            // 从源文件的内容里，复制部分数据到子文件            // 除开最后一个文件，其他文件大小都是100k            // 最后一个文件的大小是剩余的            if (i != fileNumber - 1) // 不是最后一个                eachContent = Arrays.copyOfRange(fileContent, eachSize * i, eachSize * (i + 1));            else // 最后一个                eachContent = Arrays.copyOfRange(fileContent, eachSize * i, fileContent.length);            try {                // 写出去                FileOutputStream fos = new FileOutputStream(eachFile);                fos.write(eachContent);                // 记得关闭                fos.close();                System.out.printf(&quot;输出子文件%s，其大小是 %d字节%n&quot;, eachFile.getAbsoluteFile(), eachFile.length());            } catch (IOException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }        }    }}</code></pre><h4 id="合并文件"><a href="#合并文件" class="headerlink" title="合并文件"></a>合并文件</h4><p>与拆分文件不同(先把所有数据读取到内存中)，合并文件采用另一种思路。</p><p>这种思路，不需要把所有的子文件都先读取到内存中，而是一边读取子文件的内容，一边写出到目标文件</p><p>即从eclipse.exe-0开始，读取到一个文件，就开始写出到 eclipse.exe中，然后处理eclipse.exe-1eclipse.exe-2 eclipse.exe-3 … 直到没有文件可以读</p><pre><code>package stream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import javax.security.auth.DestroyFailedException;public class TestStream {    public static void main(String[] args) {        murgeFile(&quot;d:/&quot;, &quot;eclipse.exe&quot;);    }    /**     * 合并的思路，就是从eclipse.exe-0开始，读取到一个文件，就开始写出到 eclipse.exe中，直到没有文件可以读     * @param folder     *            需要合并的文件所处于的目录     * @param fileName     *            需要合并的文件的名称     * @throws FileNotFoundException     */    private static void murgeFile(String folder, String fileName) {        try {            // 合并的目标文件            File destFile = new File(folder, fileName);            FileOutputStream fos = new FileOutputStream(destFile);            int index = 0;            while (true) {                //子文件                File eachFile = new File(folder, fileName + &quot;-&quot; + index++);                //如果子文件不存在了就结束                if (!eachFile.exists())                    break;                //读取子文件的内容                FileInputStream fis = new FileInputStream(eachFile);                byte[] eachContent = new byte[(int) eachFile.length()];                fis.read(eachContent);                fis.close();                //把子文件的内容写出去                fos.write(eachContent);                fos.flush();                System.out.printf(&quot;把子文件 %s写出到目标文件中%n&quot;,eachFile);            }            fos.close();            System.out.printf(&quot;最后目标文件的大小：%,d字节&quot; , destFile.length());        } catch (FileNotFoundException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre><h5 id="以上内容是在-http-how2j-cn-学习的时候的记录"><a href="#以上内容是在-http-how2j-cn-学习的时候的记录" class="headerlink" title="以上内容是在(http://how2j.cn) 学习的时候的记录"></a>以上内容是在(<a href="http://how2j.cn" target="_blank" rel="noopener">http://how2j.cn</a>) 学习的时候的记录</h5>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常--Java</title>
      <link href="/2019/08/06/java-yi-chang/"/>
      <url>/2019/08/06/java-yi-chang/</url>
      
        <content type="html"><![CDATA[<h1 id="Java异常部分的知识"><a href="#Java异常部分的知识" class="headerlink" title="Java异常部分的知识"></a>Java异常部分的知识</h1><h3 id="异常定义："><a href="#异常定义：" class="headerlink" title="异常定义："></a>异常定义：</h3><p>导致程序的正常流程被中断的事件，叫做异常</p><h3 id="常见异常："><a href="#常见异常：" class="headerlink" title="常见异常："></a>常见异常：</h3><p>ParseException ：解析异常，日期字符串转换为日期对象的时候，有可能抛出的异常<br>OutOfIndexException ：数组下标越界异常<br>OutOfMemoryError ：内存不足<br>ClassCastException ：类型转换异常<br>ArithmeticException ：除数为零<br>NullPointerException ：空指针异常</p><h3 id="异常处理："><a href="#异常处理：" class="headerlink" title="异常处理："></a>异常处理：</h3><p>异常处理常见手段： try catch finally throws</p><h4 id="一：try-catch"><a href="#一：try-catch" class="headerlink" title="一：try catch"></a>一：try catch</h4><ol><li>将可能抛出FileNotFoundException 文件不存在异常的代码放在try里</li><li>如果文件存在，就会顺序往下执行，并且不执行catch块中的代码</li><li>如果文件不存在，try 里的代码会立即终止，程序流程会运行到对应的catch块中</li><li>e.printStackTrace(); 会打印出方法的调用痕迹</li></ol><h4 id="二：使用异常的父类进行catch"><a href="#二：使用异常的父类进行catch" class="headerlink" title="二：使用异常的父类进行catch"></a>二：使用异常的父类进行catch</h4><ol><li>FileNotFoundException是Exception的子类，使用Exception也可以catch住FileNotFoundException<h4 id="三：多异常捕捉办法"><a href="#三：多异常捕捉办法" class="headerlink" title="三：多异常捕捉办法"></a>三：多异常捕捉办法</h4>有的时候一段代码会抛出多种异常<pre><code> new FileInputStream(f); Date d = sdf.parse(&quot;2016-06-03&quot;);</code></pre>这段代码，会抛出 文件不存在异常 FileNotFoundException 和 解析异常ParseException<br>解决办法之一是分别进行catch<pre><code> catch (FileNotFoundException e) {     System.out.println(&quot;d:/LOL.exe不存在&quot;);     e.printStackTrace(); } catch (ParseException e) {     System.out.println(&quot;日期格式解析错误&quot;);     e.printStackTrace(); }</code></pre>另外的一个方法是把多个异常放在一个catch里面一起捕捉<pre><code> catch (FileNotFoundException | ParseException e)</code></pre>不足之处是，一旦发生异常，不能确定到底是哪种异常，需要通过instanceof 进行判断具体的异常类型<pre><code> if (e instanceof FileNotFoundException)     System.out.println(&quot;d:/LOL.exe不存在&quot;); if (e instanceof ParseException)     System.out.println(&quot;日期格式解析错误&quot;);</code></pre></li></ol><h4 id="四：finally"><a href="#四：finally" class="headerlink" title="四：finally"></a>四：finally</h4><p>无论是否出现异常，finally中的代码都会被执行</p><h4 id="五：throws"><a href="#五：throws" class="headerlink" title="五：throws"></a>五：throws</h4><p>考虑如下情况：主方法调用method1，method1调用method2，method2中打开文件<br>method2中需要进行异常处理，但是method2不打算处理，而是把这个异常通过throws抛出去<br>那么method1就会接到该异常。 处理办法也是两种，要么是try catch处理掉，要么也是抛出去。<br>method1选择本地try catch住 一旦try catch住了，就相当于把这个异常消化掉了，<br>主方法在调用method1的时候，就不需要进行异常处理了</p><h4 id="六：throw和throws的区别"><a href="#六：throw和throws的区别" class="headerlink" title="六：throw和throws的区别"></a>六：throw和throws的区别</h4><p>throws与throw这两个关键字接近，不过意义不一样，有如下区别：</p><ol><li>throws 出现在方法声明上，而throw通常都出现在方法体内。</li><li>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。</li></ol><h3 id="异常分类："><a href="#异常分类：" class="headerlink" title="异常分类："></a>异常分类：</h3><p>可查异常，运行时异常和错误3种<br>其中，运行时异常和错误又叫非可查异常</p><h4 id="一：可查异常"><a href="#一：可查异常" class="headerlink" title="一：可查异常"></a>一：可查异常</h4><p>可查异常： CheckedException<br>可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException<br>如果不处理，编译器，就不让你通过</p><h4 id="二：运行时异常"><a href="#二：运行时异常" class="headerlink" title="二：运行时异常"></a>二：运行时异常</h4><p>运行时异常RuntimeException指： 不是必须进行try catch的异常<br>常见运行时异常: 除数不能为0异常:ArithmeticException ，下标越界异常:ArrayIndexOutOfBoundsException ，空指针异常:NullPointerException<br>在编写代码的时候，依然可以使用try catch throws进行处理，与可查异常不同之处在于，即便不进行try catch，也不会有编译错误<br>Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常太过于普遍，如果都需要进行捕捉，代码的可读性就会变得很糟糕。</p><h4 id="三：错误"><a href="#三：错误" class="headerlink" title="三：错误"></a>三：错误</h4><p>错误Error，指的是系统级别的异常，通常是内存用光了在默认设置下，一般java程序启动的时候，最大可以使用16m的内存如例不停的给StringBuffer追加字符，很快就把内存使用光了。抛出OutOfMemoryError与运行时异常一样，错误也是不要求强制捕捉的</p><h4 id="四：三种分类"><a href="#四：三种分类" class="headerlink" title="四：三种分类"></a>四：三种分类</h4><p>总体上异常分三类： </p><ol><li>错误</li><li>运行时异常</li><li>可查异常<br><img src="http://stepimagewm.how2j.cn/2412.png" alt><h4 id="五：运行时异常与非运行时异常的区别？"><a href="#五：运行时异常与非运行时异常的区别？" class="headerlink" title="五：运行时异常与非运行时异常的区别？"></a>五：运行时异常与非运行时异常的区别？</h4>运行时异常是不可查异常，不需要进行显式的捕捉<br>非运行时异常是可查异常，必须进行显式的捕捉，或者抛出</li></ol><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>Throwable是类，Exception和Error都继承了该类,所以在捕捉的时候，也可以使用Throwable进行捕捉<br>如图： 异常分Error和Exception,Exception里又分运行时异常和可查异常。<br><img src="http://stepimagewm.how2j.cn/742.png" alt></p><h4 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h4><p>一个英雄攻击另一个英雄的时候，如果发现另一个英雄已经挂了，就会抛出EnemyHeroIsDeadException<br>创建一个类EnemyHeroIsDeadException，并继承Exception<br>提供两个构造方法</p><ol><li><p>无参的构造方法</p></li><li><p>带参的构造方法，并调用父类的对应的构造方法</p><pre><code>class EnemyHeroIsDeadException extends Exception{ public EnemyHeroIsDeadException(){ } public EnemyHeroIsDeadException(String msg){     super(msg); }}</code></pre><h4 id="抛出自定义异常"><a href="#抛出自定义异常" class="headerlink" title="抛出自定义异常"></a>抛出自定义异常</h4><p>在Hero的attack方法中，当发现敌方英雄的血量为0的时候，抛出该异常</p></li><li><p>创建一个EnemyHeroIsDeadException实例</p></li><li><p>通过throw 抛出该异常</p></li><li><p>当前方法通过 throws 抛出该异常<br>在外部调用attack方法的时候，就需要进行捕捉，并且捕捉的时候，可以通过e.getMessage() 获取当时出错的具体原因</p><pre><code>package charactor;public class Hero { public String name; protected float hp; public void attackHero(Hero h) throws EnemyHeroIsDeadException{     if(h.hp == 0){         throw new EnemyHeroIsDeadException(h.name + &quot; 已经挂了,不需要施放技能&quot; );     } } public String toString(){     return name; } class EnemyHeroIsDeadException extends Exception{     public EnemyHeroIsDeadException(){     }     public EnemyHeroIsDeadException(String msg){         super(msg);     } } public static void main(String[] args) {     Hero garen =  new Hero();     garen.name = &quot;盖伦&quot;;     garen.hp = 616;     Hero teemo =  new Hero();     teemo.name = &quot;提莫&quot;;     teemo.hp = 0;     try {         garen.attackHero(teemo);     } catch (EnemyHeroIsDeadException e) {         // TODO Auto-generated catch block         System.out.println(&quot;异常的具体原因:&quot;+e.getMessage());         e.printStackTrace();     } }}</code></pre><h5 id="以上内容是在-http-how2j-cn-学习的时候的记录"><a href="#以上内容是在-http-how2j-cn-学习的时候的记录" class="headerlink" title="以上内容是在(http://how2j.cn) 学习的时候的记录"></a>以上内容是在(<a href="http://how2j.cn" target="_blank" rel="noopener">http://how2j.cn</a>) 学习的时候的记录</h5></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL8的安装</title>
      <link href="/2019/08/02/wo-de-bo-ke-zhu-ti/"/>
      <url>/2019/08/02/wo-de-bo-ke-zhu-ti/</url>
      
        <content type="html"><![CDATA[<p>想看更加完整的教程可以在下面的视频上面观看<br><a href="https://www.bilibili.com/video/av24331238" target="_blank" rel="noopener">原教程视频</a><br>打开MySQL的官网：<a href="https://www.mysql.com/" target="_blank" rel="noopener">mysql官网</a><br><img src="https://s2.ax1x.com/2019/08/06/efFrWj.png" alt></p><center>直接选择下载，接下来的基本按照图片步骤来就OK了</center><p><img src="https://s2.ax1x.com/2019/08/06/efFJSA.png" alt><br><img src="https://s2.ax1x.com/2019/08/06/efFNOP.png" alt><br><img src="https://s2.ax1x.com/2019/08/06/efFYQI.jpg" alt><br><img src="https://s2.ax1x.com/2019/08/06/efFtyt.jpg" alt><br><img src="https://s2.ax1x.com/2019/08/06/efF8Wd.png" alt><br><img src="https://s2.ax1x.com/2019/08/06/efFaef.jpg" alt><br><img src="https://s2.ax1x.com/2019/08/06/efFdw8.jpg" alt><br><img src="https://s2.ax1x.com/2019/08/06/efFwTS.jpg" alt><br><img src="https://s2.ax1x.com/2019/08/06/efFBFg.png" alt><br><img src="https://s2.ax1x.com/2019/08/06/efFDYQ.png" alt></p><center>中间有的步骤没有截图，但是基本都是next即可</center>]]></content>
      
      
      
        <tags>
            
            <tag> 软件安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/02/hello-world/"/>
      <url>/2019/08/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
